# Web of Science API Lite
#
# A responsive API that supports rich searching across the Web of Science Core Collection to retrieve core article metadata.  This service provides a great way to reuse Web of Science data both internally and externally to enhance  institutional repositories and research networking systems with best-in-class data. This API supports searching across the Web of Science to retrieve item-level metadata with limited fields:  - UT (Unique Identifier) - Authors - Author keywords - Document type - Title - Issue - Pages - Publication date - Source title - Volume - DOI - ISBN - ISSN   The API supports JSON and XML responses, and this documentation supports trying both response types. 
#
# The version of the OpenAPI document: 1.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Search operations
#' @description wosliterclient.Search
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ QueryQueryIdGet } \emph{ Fetch record(s) by query identifier }
#' This operation returns record(s) identified by a query identifier.
#'
#' \itemize{
#' \item \emph{ @param } query.id integer
#' \item \emph{ @param } count integer
#' \item \emph{ @param } first.record integer
#' \item \emph{ @param } sort.field character
#' \item \emph{ @returnType } \link{WosLiteResponse} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : WosLiteResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-RateLimit-Remaining-second \tab The number of requests left for the second window. \cr
#' X-RateLimit-Limit-second \tab The number of requests limit per second. \cr
#' x-paginate-by-query-id \tab The url of the next page in case your &#x60;RecordsFound &gt; count + firstRecord&#x60; Please use this url for pagination. The QueryId will live for four hours in case if inactivity.  \cr
#' }
#' \item status code : 0 | Error response 400+
#'
#' \item return type : ErrorResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-RateLimit-Remaining-second \tab The number of requests left for the second window. \cr
#' X-RateLimit-Limit-second \tab The number of requests limit per second. \cr
#' }
#' }
#'
#' \strong{ RootGet } \emph{ Submits a user query and returns results }
#' The search operation submits a search query to the specified database edition and retrieves data. This operation returns a query ID that can be used in subsequent operations to retrieve more records.
#'
#' \itemize{
#' \item \emph{ @param } database.id character
#' \item \emph{ @param } usr.query character
#' \item \emph{ @param } count integer
#' \item \emph{ @param } first.record integer
#' \item \emph{ @param } lang character
#' \item \emph{ @param } edition character
#' \item \emph{ @param } publish.time.span character
#' \item \emph{ @param } load.time.span character
#' \item \emph{ @param } sort.field character
#' \item \emph{ @returnType } \link{WosLiteResponse} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : WosLiteResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-RateLimit-Remaining-second \tab The number of requests left for the second window. \cr
#' X-RateLimit-Limit-second \tab The number of requests limit per second. \cr
#' x-paginate-by-query-id \tab The url of the next page in case your &#x60;RecordsFound &gt; count + firstRecord&#x60; Please use this url for pagination. The QueryId will live for four hours in case if inactivity.  \cr
#' }
#' \item status code : 0 | Error response 400+
#'
#' \item return type : ErrorResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-RateLimit-Remaining-second \tab The number of requests left for the second window. \cr
#' X-RateLimit-Limit-second \tab The number of requests limit per second. \cr
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  QueryQueryIdGet  ####################
#'
#' library(woslite_r_client)
#' var.query.id <- 56 # integer | Retrieve records based on query identifier.
#' var.count <- 56 # integer | Number of records to return, must be 0-100.
#' var.first.record <- 56 # integer | Specific record, if any within the result set to return. Cannot be less than 1 and greater than 100000.
#' var.sort.field <- 'sort.field_example' # character | Order by field(s). Field name and order by clause separated by '+', use A for ASC and D for DESC, ex: PY+D. Multiple values are separated by comma. If sortField was set on the original query, this parameter should be set as sorting is not a property of the query.
#'
#' #Fetch record(s) by query identifier
#' api.instance <- SearchApi$new()
#'
#' #Configure API key authorization: key
#' api.instance$apiClient$apiKeys['X-ApiKey'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$QueryQueryIdGet(var.query.id, var.count, var.first.record, sort.field=var.sort.field)
#'
#'
#' ####################  RootGet  ####################
#'
#' library(woslite_r_client)
#' var.database.id <- 'database.id_example' # character | Database to search. Must be a valid database ID, one of the following: BCI/BIOABS/BIOSIS/CCC/DCI/DIIDW/MEDLINE/WOK/WOS/ZOOREC. WOK represents all databases.
#' var.usr.query <- 'usr.query_example' # character | User query for requesting data, ex: TS=(cadmium). The query parser will return errors for invalid queries.
#' var.count <- 56 # integer | Number of records to return, must be 0-100.
#' var.first.record <- 56 # integer | Specific record, if any within the result set to return. Cannot be less than 1 and greater than 100000.
#' var.lang <- 'lang_example' # character | Language of search. This element can take only one value: en for English. If no language is specified, English is passed by default.
#' var.edition <- 'edition_example' # character | Edition(s) to be searched. If null, user permissions will be substituted. Must include the name of the collection and edition name separated by '+', ex: WOS+SCI. Multiple editions are separated by ','. Editions available for collection(WOS) - AHCI,CCR,IC,ISSHP,ISTP,SCI,SSCI,BHCI,BSCI and ESCI.
#' var.publish.time.span <- 'publish.time.span_example' # character | This element specifies a range of publication dates. If publishTimeSpan is used, the loadTimeSpan parameter must be omitted. If publishTimeSpan and loadTimeSpan are both omitted, then the maximum time span will be inferred from the editions data. Beginning and end dates should be specified in the yyyy-mm-dd format separated by +, ex: 1993-01-01+2009-12-31.
#' var.load.time.span <- 'load.time.span_example' # character | Load time span (otherwise described as symbolic time span) defines a range of load dates. The load date is the date a record was added to the database. If load date is specified, the publishTimeSpan parameter must be omitted. If both publishTimeSpan and loadTimeSpan are omitted, the maximum publication date will be inferred from the editions data. Any of D/W/M/Y prefixed with a number where D-Day, M-Month, W-Week, Y-Year allowed. Acceptable value range for Day(0-6), Week(1-52), Month(1-12) and Year(0-10), ex: 5D,30W,10M,8Y.
#' var.sort.field <- 'sort.field_example' # character | Order by field(s). Field name and order by clause separated by '+', use A for ASC and D for DESC, ex: PY+D. Multiple values are separated by comma.
#'
#' #Submits a user query and returns results
#' api.instance <- SearchApi$new()
#'
#' #Configure API key authorization: key
#' api.instance$apiClient$apiKeys['X-ApiKey'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$RootGet(var.database.id, var.usr.query, var.count, var.first.record, lang=var.lang, edition=var.edition, publish.time.span=var.publish.time.span, load.time.span=var.load.time.span, sort.field=var.sort.field)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
SearchApi <- R6::R6Class(
  'SearchApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    QueryQueryIdGet = function(query.id, count, first.record, sort.field=NULL, ...){
      apiResponse <- self$QueryQueryIdGetWithHttpInfo(query.id, count, first.record, sort.field, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    QueryQueryIdGetWithHttpInfo = function(query.id, count, first.record, sort.field=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`query.id`)) {
        stop("Missing required parameter `query.id`.")
      }

      if (missing(`count`)) {
        stop("Missing required parameter `count`.")
      }

      if (missing(`first.record`)) {
        stop("Missing required parameter `first.record`.")
      }

      queryParams['count'] <- count

      queryParams['firstRecord'] <- first.record

      queryParams['sortField'] <- sort.field

      body <- NULL
      urlPath <- "/query/{queryId}"
      if (!missing(`query.id`)) {
        urlPath <- gsub(paste0("\\{", "queryId", "\\}"), URLencode(as.character(`query.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-ApiKey" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-ApiKey"]) > 0) {
        headerParams['X-ApiKey'] <- paste(unlist(self$apiClient$apiKeys["X-ApiKey"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "WosLiteResponse", loadNamespace("woslite_r_client")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RootGet = function(database.id, usr.query, count, first.record, lang=NULL, edition=NULL, publish.time.span=NULL, load.time.span=NULL, sort.field=NULL, ...){
      apiResponse <- self$RootGetWithHttpInfo(database.id, usr.query, count, first.record, lang, edition, publish.time.span, load.time.span, sort.field, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RootGetWithHttpInfo = function(database.id, usr.query, count, first.record, lang=NULL, edition=NULL, publish.time.span=NULL, load.time.span=NULL, sort.field=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`database.id`)) {
        stop("Missing required parameter `database.id`.")
      }

      if (missing(`usr.query`)) {
        stop("Missing required parameter `usr.query`.")
      }

      if (missing(`count`)) {
        stop("Missing required parameter `count`.")
      }

      if (missing(`first.record`)) {
        stop("Missing required parameter `first.record`.")
      }

      queryParams['databaseId'] <- database.id

      queryParams['lang'] <- lang

      queryParams['usrQuery'] <- usr.query

      queryParams['edition'] <- edition

      queryParams['publishTimeSpan'] <- publish.time.span

      queryParams['loadTimeSpan'] <- load.time.span

      queryParams['count'] <- count

      queryParams['firstRecord'] <- first.record

      queryParams['sortField'] <- sort.field

      body <- NULL
      urlPath <- "/"
      # API key authentication
      if ("X-ApiKey" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-ApiKey"]) > 0) {
        headerParams['X-ApiKey'] <- paste(unlist(self$apiClient$apiKeys["X-ApiKey"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "WosLiteResponse", loadNamespace("woslite_r_client")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
